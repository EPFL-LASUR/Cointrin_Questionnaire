# Data Cleaning Cointrin Questionnaire
This notebook is used to clean invalid answers from the dataset. It should be ran first in the pipeline.

## Load Data
This code block loads every needed data and code. It also creates variables containing the path to some folders that are or will contain data.
```{r}
here::i_am(file.path("notebook", "data_cleaning.Rmd"))
source(here::here(file.path("R", "cleaning.R")))

filename <- "data_project_1074950_2025_12_05.sav" # Change the name if needed

processed_data_folder <- file.path("..", "data", "processed")
raw_data_folder <- file.path("..", "data", "raw")

if (!dir.exists(processed_data_folder)) {
  dir.create(processed_data_folder, recursive = TRUE)
}

raw_data <- haven::read_sav(
  file.path(
    raw_data_folder, filename
  )
)
```

## Remove tester answers
This code block removes all test questionnaires that have been filled during the making of the questionnaire.
```{r}
no_tester <- dplyr::filter(raw_data, tester != 1)
```


## Remove users that answered with another aphabet/language
In this code block, we are removing users that answered to at least one open questions in an other language than french. This section is innactive. Uncomment the line below and switch between the two no_duplicates declaration in the next block to make it active again.
```{r}
# french <- dplyr::filter(no_tester, !lfdn %in% c(56, 192, 221, 396, 1393, 380, 426, 493, 473, 708, 723))
```

## Remove Duplicates
In this code block, we are trying to catch peoples that answered multiples times to the questionnaire. The duplicates list is a hand made list that contains users who had suspect answers in the open questions.
```{r}
duplicates <- c(c(848, 847), c(509, 504), c(662, 661), c(139, 138), c(745, 744), c(1373, 1372))
# no_duplicates <- french
no_duplicates <- no_tester
for (couple in duplicates) {
  if (calculate_same_answers(no_tester, couple[1], couple[2]) > 0.9) {
    no_duplicates <- dplyr::filter(no_duplicates, lfdn != couple[2])
    print(couple[1])
  }
}
```

## Save cleaned file
Here, we save the cleaned data in the processed data folder.
```{r}
if (!dir.exists(processed_data_folder)) {
  dir.create(processed_data_folder, recursive = TRUE)
}

haven::write_sav(no_duplicates, file.path(processed_data_folder, "cleaned_data.sav"))
```
